---
layout: post
title: When you code, do you know your Master(s)?
date: '2007-12-29T10:32:00.001-08:00'
author: Kevin Moore
tags:
- Programming
- important
- interesting
- computing
modified_time: '2007-12-29T10:33:14.155-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-5315822412374121655
blogger_orig_url: http://work.j832.com/2007/12/when-you-code-do-you-know-your-masters.html
---

<p><img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="105" alt="Master Chief - Everyone&#39;s Master" src="http://j832.com/workBlogFiles/WhenyoucodedoyouknowyourMasters_9445/halo3masterchief_thumb.png" width="150" align="right" border="0" /><em>There are a whole set of blog posts floating around my head. Discussions of immutability, pre-condition checking, etc. I realized I needed to cover a meta-topic first: the notion of &quot;masters&quot; while programming.</em></p>  <p>This is a concept I think everyone has, but for most, it remains fuzzy, undefined and un-discussed--which is fine, if you work by yourself.</p>  <p>As I've dived into the software engineering role in the last few months, I've been required to justify my implementation decisions and opinions with co-workers. Given the seemingly limitless ways in which one could solve a given problem with a file full of curly braces and semi-colons, why did I choose the approach I did? Why do I want to change a bunch of existing code? Why am I asking my colleagues to change how they write software?</p>  <p>When it's a simple matter of &quot;does it work or not&quot; there isn't much of a problem, but as many know, writing solid code goes well beyond getting things to build and run.</p>  <p>So, what drives how you write software? When you are at a cross roads (with a co-worker or even with yourself) about how to approach implementation, what guides your discussion? These are your masters.</p>  <p>Examples:</p>  <ul>   <li>Minimize code size</li>    <li>Minimize code complexity</li>    <li>Minimize unnecessary code churn</li>    <li>Maximize code readability</li>    <li>Maximize correctness</li>    <li>Maximize robustness</li>    <li>Maximize flexibility</li>    <li>Maximize code maintainability </li>    <li>Maximize CPU performance characteristics</li>    <li>Maximize Memory performance characteristics</li>    <li>Maximize API ease-of-use</li>    <li>Maximize the chance another dev will use an API correctly (see <a href="http://blogs.msdn.com/brada/archive/2003/10/02/50420.aspx">Pit of Success</a>)</li>    <li>Opt for immutable data structures</li>    <li>Opt for thread-safe data structures and APIs</li>    <li>Verify pre-conditions</li>    <li>Follow design guidelines</li>    <li>Get it done yesterday!</li> </ul>  <p>And none of these have anything to do with solving the problem at hand. They are, for lack of a better term, taxes. Well, except for <em>get it done yesterday</em>.</p>  <p>Some observations:</p>  <p>1) Many (Most? All?) of the<em> </em>masters conflict with at least one other master. CPU vs Memory performance is a trade off for many algorithms. Performance optimizations often hurt code readability. API ease-of-use often bumps up against immutability and thread safety. Therefor...</p>  <p>2) Context really matters. This is an important point to bring up when discussing with co-workers. <em>In this situation</em>, which master is most important?</p>  <p>3) When making your case in a disagreement, make it in terms of the masters you are prioritizing in a given situation. If someone doesn't understand the importance of--say--immutability, you'd better be able to articulate it.</p>  <p>4) Speaking in terms of masters makes everyone a lot more sane. How often have implementation discussions turned into irrational arguments? Using a master-focused format, I've found disagreements turn into pretty simple cases of a disagreement about the relative importance of two masters. Other times, it's a matter of agreeing on an exception to general rule. &quot;While in general, Master A is more important than Master B, in this situation, we should prioritize B because of X, Y, Z...&quot;</p>  <p>5) &quot;Fake&quot; masters get exposed--vices wearing the mask of a real master. This is amazingly important, too. Lazy often wears the mask of <em>code size</em> or <em>get it done yesterday</em>. <em>Clever</em> often wears the guise of unnecessary flexibility or performance improvements, while increasing code complexity and decreasing code readability. (I'm often guilty of this.)</p>  <p>So...</p>  <p>Next time you are struggling with several valid ways to implement something, make the mental check-list: what masters am I serving with each implementation? What masters are really important in this situation?</p>  <p>Next time you disagree with a co-worker about an implementation, ask yourself: what masters is she arguing for? What masters am I arguing for? What masters really matter? Maybe step back a bit and talk through your respective masters and make sure you both understand before you dig in.</p>  <p>Next time you are trying to <em>get it done yesterday</em>, ask yourself: am I just being lazy? :-)</p>  <p>Happy hacking...</p>  <p><em>Note 1: Huge props to my co-worker, </em><a href="http://dpotter.net/Technical/"><em>David Potter</em></a><em>. A more brilliant, friendly, and fun colleagues I could not ask for. We've been using this master-focused mind set for weeks now and it makes collaborating a blast.</em></p>  <p><em>Note 2: I always get a little nervous posting these long, pseudo-philosophical rants with no source code. As always, if you write a comment saying you read this far (and you don't think I'm crazy) you'll make my day.</em></p>  