---
layout: post
title: 'Reasons to subclass: Great, Good, Okay'
date: '2007-11-21T18:11:00.001-08:00'
author: Kevin Moore
tags:
- WPF
- Programming
- ".NET"
- C#
modified_time: '2007-11-21T18:11:27.483-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-6492458850511738218
blogger_orig_url: http://work.j832.com/2007/11/reasons-to-subclass-great-good-okay.html
---

<p><em>Shout-out to brilliant developer (and my co-worker) </em><a href="http://dpotter.net/Technical/"><em>David Potter</em></a><em>, who--through hours of discussion--helped me arrive at this 'thought'.</em></p>  <p><em>FYI: I use a lot of WPF examples in here. Apologies to the non-WPF devs.</em></p>  <p>Back in June, I wrote a post titled: <a href="http://work.j832.com/2007/06/don-subclass-panel-unless-you-making.html">Don't subclass a Panel, unless you're making a Panel</a>.</p>  <p>In that post, I outlined the 'great' reason to use subclassing (read, inheritance):</p>  <blockquote>   <p>I read a great internal paper at MS once--written by one of those brilliant old-guard devs with decades of perspective. The point the author pushed: use inheritance only for polymorphism. Translated: when making MyGrid, only subclass Grid if you mean for people to treat your new MyGrid just like another Grid. Code (and a user, for the most part) that deals with Grid should be able to &quot;deal&quot; with MyGrid without any issues.</p> </blockquote>  <p>I use a strong word there: only.</p>  <p>Now with time and experience comes perspective.</p>  <p>I'm going to make this philosophy a bit more nuanced by introducing categories of subclassing: great, good, and okay.</p>  <p>My argument: there are times to use each, but the further you get away from 'great', the more trouble you can get in and the more careful and thoughtful you should be.</p>  <h3>Great subclassing: for polymorphism.</h3>  <p>Examples here: Stream (from mscorlib) and UIElement (from WPF).</p>  <p>Stream is worthless by itself. It's meant to be the base class for something else. But there are innumerable features of the CLR that deal with Stream generically, without much concern for any subclass.</p>  <p>UIElement is similar. Basically worthless by itself. Designed to be a baseclass. But things like WPF layout (Measure/Arrange) deal explicitly with UIElement, ignoring any details of any subclass.</p>  <p>If you create a Foo class and have other classes that take a Foo in a constructor or method argument, even though Foo is abstract or rarely used by itself you are playing in the 'great' end of the subclassing spectrum.</p>  <h3>Good subclassing: cognitive simplicity</h3>  <p>If 'great' subclassing is for software components, 'good' subclassing is for humans.</p>  <p>ContentControl (WPF) is a pretty good example. I can't think of any constructor or method that takes ContentControl as a parameter. </p>  <p>We could imagine Button and Label and ScrollViewer all re-exposing the common properties (Content, ContentTemplate, ContentTemplateSelector) without any changes in functionality.</p>  <p>But! It's really nice that users can look at Label and say &quot;oh, that's a ContentControl&quot; and immediately have a valid mental model of how to use it.</p>  <p>The baseclass, in this respect, provides a grouping paradigm for a user to understand classes of types.</p>  <p>While this is a nice feature, it has its issues.</p>  <p>ButtonBase is a good example.</p>  <p>ButtonBase is the 'clickable' widget in WPF.</p>  <p>Almost everything that is clickable subclasses ButtonBase.</p>  <p>ButtonBase subclasses ContentControl.</p>  <p>ContentControl is the 'content' widget in WPF.</p>  <p>Almost everything in WPF that has content is a content control. Well, almost. ContentPresenter has the same properties that ContentControl has regarding content (Content, ContentTemplate, ContentTemplateSelector).</p>  <p>But they don't share a baseclass. Why?</p>  <p>Well, because ContentControl is a Control.</p>  <p>Control is the 'template-able' widget in WPF. It lets you swap out the chrome.</p>  <p>ContentPresenter doesn't let you swap out the chrome, just the template for the data.</p>  <p>So, we could really imagine three separate classes, all of which derive from FrameworkElement.</p>  <ul>   <li>ClickElement: exposes the click properties/methods/events. </li>    <li>ContentElement: exposes the content properties/methods/events (Yes, this class name already exists for text stuff. Play along...) </li>    <li>TemplateElement: exposes the template properties/methods/events (this is what Control is now). </li> </ul>  <p>The fact that ButtonBase subclasses in a specific order is kinda arbitrary.</p>  <p>One could imagine wanting a template-able, click-able element that doesn't have content.</p>  <p>One could imagine wanting a click-able, element that holds content that isn't template-able.</p>  <p>Single inheritance forces framework authors to choose. This can be annoying if you want a re-mix of the available features.</p>  <p>A great example of this: TransitionPresenter (from the <a href="http://j832.com/BagOTricks/">bag-o-tricks</a>).</p>  <p>It has all of the content properties, but it's not a ContentPresenter or a ContentControl. (The way it does its visual tree is different than both of those controls.)</p>  <p>It turns out to be impossible to subclass ContentPresenter and it's confusing to subclass ContentControl (because TransitionPresenter doesn't use a ControlTemplate).</p>  <p>A really smart dev who was doing code clean-up actually changed the baseclass from FrameworkElement to ContentControl, thinking he was making things simpler.</p>  <p>This is bad! A user will then expect to be able to use the Template property to change the chrome. This is the same problem with making MyGrid from Grid unless you want people treating it like any other Grid.</p>  <p>This trap is usually because of the third type...</p>  <h3>Okay subclassing: tactical code reuse</h3>  <p>If you have 15 classes that all have a Foo, Bar, and Baz property, having a common baseclass just saves code. Less to document. Less to test. Less to mess up.</p>  <p>Fine.</p>  <p>But if sharing some common state is your only goal, just make sure you acknowledge (along with the rest of your team) that is why you're doing it. Put it in the code comments of the class.</p>  <p>In some respects this is less dangerous than the 'good' reason to subclass because the FooBarBaz class probably doesn't have much meaning or use beyond your tactical reasons. As soon as it does, though, you can fall into the MyGrid trap.</p>  <h3>In closing</h3>  <p>This was a really long write-up.</p>  <p>I guess my final advice is be careful.</p>  <p>As with anything in life, if you try to be clever for clever's sake, you'll get burned.</p>  <p>If you try to use every feature of a language or a framework just to add spice to your afternoon of coding, you'll get burned.</p>  <p>As I discussed in my <a href="http://work.j832.com/2007/11/importance-of-patterns-and-guidelines.html">post about patters and guidelines</a>, always try to understand the implications of the tools/tricks you use when coding.</p>  <p>And that's all I have to say about that.</p>  <p>Happy hacking.</p>  <p><em>Did you find this interesting? Let me know. I'd hate to think I was riffing all this out just to make my tendinitis worse.</em></p> 