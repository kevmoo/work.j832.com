---
layout: post
title: Going beyond Monitor.Enter/Exit (C# lock) with LockHelper
date: '2007-11-13T21:13:00.001-08:00'
author: Kevin Moore
tags:
- Programming
- ".NET"
- C#
- threading
- computing
modified_time: '2007-11-13T21:18:00.955-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-1077566242360861485
blogger_orig_url: http://work.j832.com/2007/11/going-beyond-monitorenterexit-c-lock.html
---

<p><em>Sample code: </em><a href="http://j832.com/workBlogFiles/LockHelper.cs"><strong><em>LockHelper.cs</em></strong></a><strong><em> [6KB]</em></strong></p>  <p>Debugging threading issues is painful.</p>  <p>Really painful.</p>  <p>One of the most painful problems: dealing with deadlocks--waiting forever on a Monitor.Enter (C# lock) and not knowing which thread already has the lock.</p>  <p>I tried to <a href="http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=2235119&amp;SiteID=1">dig in on this</a> on the <a href="http://forums.microsoft.com/MSDN/ShowForum.aspx?ForumID=39&amp;SiteID=1">CLR Base Class Library Forum</a>. I was hopeful, since Java has a method [Thread.holdsLock(obj)] that returns the holder of the current lock</p>  <p>Sadly, .NET lacks this functionality.</p>  <p>Enter a can-do attitude: why not build it myself.</p>  <p>Enter LockHelper.</p>  <p>Goals:</p>  <ul>   <li>Identical semantics to Monitor.Enter/Exit </li>    <li>Enable other Monitor features (Pulse, Wait) </li>    <li>Close to identical syntax to C# lock </li>    <li>Ability to know, given an instance of LockHelper, the current owning thread </li>    <li>Other conveniences (CheckAccess and VerifyAccess) </li> </ul>  <p>Wrapping Monitor.Enter/Exit isn't that hard. As you see with the implementation, it's pretty easy to leverage IDisposable + the C# <strong>using</strong> statement to get syntax that is close to <strong>lock</strong>.</p>  <p>Instead of:</p>  <blockquote>   <p>public void Foo()      <br />{       <br />&#xA0;&#xA0;&#xA0; lock(m_lockObject)       <br />&#xA0;&#xA0;&#xA0; {       <br />&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; //do stuff       <br />&#xA0;&#xA0;&#xA0; }       <br />}       <br />      <br />private readonly object m_lockObject = new object();</p> </blockquote>  <p>Do this:</p>  <blockquote>   <p>public void Foo()      <br />{       <br />&#xA0;&#xA0;&#xA0; using(m_lockObject.GetLock())       <br />&#xA0;&#xA0;&#xA0; {       <br />&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; //do stuff       <br />&#xA0;&#xA0;&#xA0; }       <br />}       <br />      <br />private readonly LockHelper m_lockObject = new LockHelper(&quot;foo&quot;);</p> </blockquote>  <p><strong>GetLock()</strong> returns a private class that implements <strong>IDisposable</strong>. The <strong>using</strong> block has identical try/finally semantics to the <strong>lock</strong> keyword. (See <a href="http://msdn2.microsoft.com/en-us/library/ms173179(VS.80).aspx">this article</a> in the C# Programming Guide for details.)</p>  <p>I had to be religious about storing away <strong>Thread.Name</strong> for the current thread at all times. While debugging, I found that VS was often unable to evaluate the property of the owning thread.</p>  <p>So now I have enough plumbing to figure out which thread has a lock on my lock object. Cool.</p>  <p>What else?</p>  <p>Exposing <strong>Pulse</strong> and <strong>Wait</strong> was pretty easy. Beyond these basics, I stole the CheckAccess/VerifyAccess ideas from WPF.</p>  <p>Often times one will have private helpers in a class that access/modify the state of a class. Often times these methods (should) run under the assumption that they were called in the context of a lock.</p>  <p>The simple way around this is to re-lock the object inside the helper method, but this can be a source of deadlocks and really doesn't help maintain the implementation contract.</p>  <p>What one wants: a way to assert that the calling thread owns a lock.</p>  <p>Done!</p>  <p><strong>CheckAccess</strong> returns <strong>true</strong> if the current thread has the lock. Otherwise, <strong>false</strong>.</p>  <p><strong>VerifyAccess</strong> goes a step further and throws an exception if the calling thread doesn't own the lock.</p>  <p>Pretty cool, huh?</p>  <p><em>Note: I was not on the CLR team at Microsoft. I was not a developer at Microsoft, just a lowly PM. I'm pretty confident this works. At least I haven't hit any issues with it. Please be careful throwing this in your own projects. This is certainly out of the realm of advertised best-practices from MS.</em></p>  <p>It works for me, though.</p>  <p>Let me know what you think.</p>  <p>Happy hacking!</p> 