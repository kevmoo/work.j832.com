---
layout: post
title: 'Threading fun: Monitor.Wait, Monitor.Pulse'
date: '2007-10-26T14:02:00.001-07:00'
author: Kevin Moore
tags:
- Programming
- threading
modified_time: '2008-01-27T14:36:03.024-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-3332425099998730134
blogger_orig_url: http://work.j832.com/2007/10/threading-fun-monitorwait-monitorpulse.html
---

<p>Threading is pretty scary. An solid grasp of threading, as a brilliant dev lead at Microsoft once told me, was one thing that consistently separated the &quot;men/women from the boys/girls&quot; in the engineering discipline.</p>  <p>Here's my attempt to sound adult. (Forgive me if my voice cracks.)</p>  <p><em>The Scenario</em>: You have a bunch of threads running around doing work--in this case, adding random numbers to a collection. You have another thread with the aggregation job: take all of the numbers in the collection, add them to a running total, and clear out the collection.</p>  <p>This is a simplification of a problem I was faced with on my current gig: handle multiple &quot;users&quot; via separate WCF connections (coming in on separate threads). Aggregate their work requests and process them on a 'worker' thread. All while staying super responsive.</p>  <p>So you always have the one thread that's waiting around for work. How does it wait? The simple answer would be a while-true loop that's always polling.</p>  <p>That'll peg a thread pretty quick while doing a bunch of unneeded locking of your synchronization object. One could add some sleep statements to the loop to minimize the impact, but that feels like a bandage.</p>  <p>What one wants: a way to have the processing thread &quot;wait&quot; to until there actually is work to do.</p>  <p>Enter <strong>Monitor.Wait</strong> and <strong>Monitor.Pulse</strong>.</p>  <p>Mike Woodring <a href="http://www.pluralsight.com/blogs/mike/archive/2004/12/13/3905.aspx">does a pretty good job of explaining this</a> (with a very funny title/analogy), but I really wanted a fully baked and un-contrived code sample.</p>  <p>So here it is. In exactly 100 lines of code.</p>  <p><a href="http://j832.com/workBlogFiles/MonitorWaitPulseFun.cs"><strong>MonitorWaitPulseFun.cs</strong></a><strong> [3KB]</strong></p>  <p><strong>Wait</strong> and <strong>Pulse</strong> both must be called in the context of a <strong>lock</strong> (<strong>Monitor.Enter/Exit</strong>) for the provided object.</p>  <p><strong>Wait</strong> [Line 58] basically gives up the <strong>lock</strong> (and allows other code blocked by the lock to run) and waits until <strong>Pulse</strong> [Line 43] is called on another thread. The 'wait' thread then gets back in line for the lock and continues execution from where it left off.</p>  <p>It's a bit weird to accept that a lock for a given object is temporarily given up between the curly braces, but that's what happens.</p>  <p>The only hiccup I ran into was realizing that one really needs to be careful to make sure pulse is called enough, especially when shutting down. 'Wait' will wait forever if it doesn't get kicked.</p>  <p><em>A note</em>: I go this all working with a <strong>WaitHandle</strong> initially (specifically, <strong>AutoResetEvent</strong>), but I realized it was a lot more involved and (after some research) a lot heavier than I needed. WaitHandle actually wraps some Win32 stuff that goes way beyond what I need for this scenario.</p>  <p>Anyway, here's my foray into non-WPF technical blogging.</p>  <p>Interesting? Helpful?</p>  <p>Happy hacking...</p>