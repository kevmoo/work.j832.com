---
layout: post
title: The importance of patterns and guidelines in software development
date: '2007-11-01T09:39:00.001-07:00'
author: Kevin Moore
tags:
- Programming
- ".NET"
- C#
modified_time: '2007-11-01T10:04:02.244-07:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-8201066889940628427
blogger_orig_url: http://work.j832.com/2007/11/importance-of-patterns-and-guidelines.html
---

<em>I've been pulling my hair out on IDisposable, Dispose() and protected virtual Dispose(bool disposing) the last 24 hours.</em></p> <p><em>I think I've figured it out. Finally!</em><br /><br /><em>I started writing a whole entry on it, but then I realized there is a whole prequel that needs to be written first. So...</em><br /><br />We're talking about patterns and guidelines for software here, my friends. They exist to ensure consistent behavior and therefor consistent expectations. This is for direct users of your classes and also those who subclass your classes. The problem with patterns, though, is that they become customs. We do them without asking why we do them. Then we start questioning why we do them if we don't fully understand. We might even start tweaking them if they get cumbersome, which can cause unexpected consequences later on.<br /><br />So it's always good to understand why (at least at some level) we implement a pattern.<br /><br />My favorite example: events.<br /><br />So you add a public event to your class:<br /><pre>public event EventHandler Updated;</pre><br />And because you were told to, you implement:<br /><pre>protected virtual void OnUpdated(EventArgs args)<br />{<br /> EventHandler handler = Updated;<br /> if(handler != null)<br /> {<br />   handler(this, args);<br /> }<br />}</pre><br />Like a robot. Do yo know why? Really?<br /><br /><strong>Q: </strong>Why protected?<br /><strong>A: </strong>So a subclass can raise your event. The C# compiler is doing work behind the scenes. You don't see that the event really has both public and private surface area. Only the class that defines the event can raise it directly.<br /><br /><strong>Q: </strong>Why virtual?<br /><strong>A: </strong>Because a subclass might want to intercept the event and take some action on it. It's cumbersome for a subclass to register an event listener on itself.<br /><br /><strong>Q: </strong>Why create the 'handler' field in the method? Seems like a waste of a variable.<br /><strong>A: </strong>Threading. To ensure that between the check for null and the call, the event hasn't been unregistered. (But I don't have multithreaded stuff in my library, you say. Right. But might you tomorrow? Might a subclass? Might a direct user of your library?)<br /><br /><strong>Q: </strong>Why not simplify the method signature to take no parameters? EventArgs is empty, right?. I should just handle that in the method, right?<br /><strong>A: </strong>No. Some subclasses might want to pass a different EventArgs to the method. They might want to pass more information via FooEventArgs. If you lock down the method signature, you are locking them out of extensibility. (Working on WPF, we actually got a bug about this with OnCollectionChanged in ObservableCollection).<br /><br />See! Such a simple pattern, yet so many nuances!<br /><br />You might do this work even if you haven't imagined any subclasses. You are doing it just in case.<br /><br />In fact, the only good reason not to do this work is if you seal your class. Even then, what if the class gets unsealed in the future? Will you remember re-implement the pattern the right way?<br /><br />Better to do it correctly from the start.<br /><br />I need to get some work done now. In the next day or two, I'll post my discoveries on IDisposable.<br /><br />In the mean time, ask yourself: am I cutting corners with patterns? Am I implementing patters which I don't fully understand?<br /><br />Hmm...<br /><br />Happy hacking.