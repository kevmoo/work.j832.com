---
layout: post
title: Recursion, Linq, etc. - 3rd Times the Charm
date: '2008-01-18T08:12:00.001-08:00'
author: Kevin Moore
tags:
- Programming
- ".NET"
- C#
- Linq
- interesting
modified_time: '2008-01-19T19:10:15.641-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-8711110054247261732
blogger_orig_url: http://work.j832.com/2008/01/recursion-linq-etc-3rd-times-charm.html
---

<p>The joke about Microsoft is that it always takes them <a href="http://www.google.com/search?q=microsoft+%22three+times+to+get+it+right%22">three times to get it right</a>.</p>  <p>If you look at my posts on the game Set in WPF, it would seem I follow <a href="http://work.j832.com/2008/01/wpf-set-xbap.html">the</a> <a href="http://work.j832.com/2008/01/game-in-wpf-redux.html">same</a> <a href="http://work.j832.com/2008/01/wpf-set-this-is-good-stopping-spot.html">pattern</a>.</p>  <p>Well, here I go again.</p>  <p>Let's start simple: I have a path to a directory and I want to enumerate over all of it's subdirectories recursively. To be super concrete:</p>  <div style="font-family: monospace"><span style="color: #0000ff">string</span>[] startPaths = <span style="color: #0000ff">new</span>&#160;<span style="color: #0000ff">string</span>[] { <span style="color: #a31515">@&quot;D:\j832_svn\PublicSoftware\&quot;</span> };&#160; <br /><span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #0000ff">string</span>&gt; subPaths = SelectRecursivePaths(startPaths);</div>  <p>Easy enough.</p>  <p>What's the scenario-specific implementation of <code>SelectRecursive</code>? Well, our friend <code>System.IO.Directory</code> provides what we need.</p>  <div style="font-family: monospace"><span style="color: #0000ff">private</span>&#160;<span style="color: #0000ff">static</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #0000ff">string</span>&gt; SelectRecursivePaths(<span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #0000ff">string</span>&gt; paths)     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000ff">foreach</span> (<span style="color: #0000ff">string</span> path <span style="color: #0000ff">in</span> paths)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> path;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">foreach</span> (<span style="color: #0000ff">string</span> subPath <span style="color: #0000ff">in</span> SelectRecursivePaths(<span style="color: #2b91af">Directory</span>.GetDirectories(path)))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> subPath;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>This code does the job for doing an in-order, recursive traversal of all of all of the directories. But it isn't very Linq-ish, is it?</p>  <h3>Getting Linq-ish: SelectRecursiveSimple</h3>  <p>Could there be a way to extract out the call to <code>Directory.GetDirectories</code> such that this method could be used over any homogenous, hierarchical structure? Yup.</p>  <div style="font-family: monospace"><span style="color: #0000ff">public</span>&#160;<span style="color: #0000ff">static</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; SelectRecursiveSimple&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span style="color: #0000ff">this</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span style="color: #2b91af">Func</span>&lt;TSource, <span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt;&gt; recursiveSelector)     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000ff">foreach</span> (TSource element <span style="color: #0000ff">in</span> source)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> element;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">foreach</span> (TSource subElement <span style="color: #0000ff">in</span> recursiveSelector(element).SelectRecursiveSimple(recursiveSelector))     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> subElement;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}</div>  <p>Now we change the call site to embody the call to <code>GetDirectories</code>:</p>  <div style="font-family: monospace"><span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #0000ff">string</span>&gt; subPaths = startPaths.SelectRecursiveSimple(path =&gt; <span style="color: #2b91af">Directory</span>.GetDirectories(path));</div>  <p>I love <a href="http://msdn2.microsoft.com/en-us/library/bb397687.aspx">lambda expressions</a> and <a href="http://msdn2.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>.</p>  <p>With me so far?</p>  <h3>Getting Clever: SelectRecursiveClever</h3>  <p>Now we go back to my clever idea from <a href="http://work.j832.com/2008/01/flattening-recursive-algorithms-is-like.html">Tuesday</a> and <a href="http://work.j832.com/2008/01/flattening-recursive-algorithms-with.html">Wednesday</a> about flattening recursion. The code I ended up with:</p>  <div style="font-family: monospace"><span style="color: #0000ff">public</span>&#160;<span style="color: #0000ff">static</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; SelectRecursiveClever&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span style="color: #0000ff">this</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span style="color: #2b91af">Func</span>&lt;TSource, <span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt;&gt; recursiveSelector)     <br />{     <br />&#160;&#160;&#160; <span style="color: #2b91af">Stack</span>&lt;TSource&gt; stack = <span style="color: #0000ff">new</span>&#160;<span style="color: #2b91af">Stack</span>&lt;TSource&gt;();     <br />&#160;&#160;&#160; source.Reverse().ForEach(stack.Push);     <br />&#160;&#160;&#160; <span style="color: #0000ff">while</span> (stack.Count &gt; 0)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource current = stack.Pop();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; recursiveSelector(current).Reverse().ForEach(stack.Push);     <br />&#160;&#160;&#160; }     <br />}</div>  <p><em>Note: <code>ForEach</code> is an extension method I created that does what <code>Array.ForEach</code> does: calls an <code>Action&lt;T&gt;</code> delegate on each item. In this case, pushing every item in the sequence into the stack.</em></p>  <p>Now the caller-side behavior of this is exactly the same as the &quot;simple&quot; version above. The implementation tries to be &quot;clever&quot; though, by discarding the &quot;naive&quot; use of recursion by replacing the <em>call stack</em> with a <em>local stack</em>. I was quite proud of this implementation. As I said on Tuesday:</p>  <blockquote>If you can flatten a recursive implementation, you will have a better understanding of what's really going on under the covers.</blockquote>  <p>Gulp. Perhaps I spoke to soon.</p>  <h3>The Problem with Clever</h3>  <p>I showed a co-worker this code. It took a bit of work to explain the use of <code>.Reverse()</code>. Stacks are Last-in-first-out, so if you want to get the first item out first, you have to put it in last.</p>  <p>Explaining this hurt my head a bit. In the &quot;simple&quot;--read &quot;naive&quot;--implementation, one didn't have to reverse the enumeration. Why should the flattened version be different?</p>  <p>The answer: it shouldn't.</p>  <p>At some point in the &quot;clever&quot; implementation, every item is on the stack. This means if you have a very wide tree, the stack could grow to be huge.</p>  <p>Imagine your <code>recursiveSelector</code> is smart about not loading all items at a given level into memory at one time--the benefit of sequences, right? It doesn't matter, because <code>SelectRecursiveClever</code> <strong><em>will</em></strong> load everything in one level into a stack. It trades the potential benefit of a smaller call stack with the potential blow-up of your working set when iterate over a folder with 10,000 sub-folders.</p>  <p>Oops.</p>  <p>You <strong><em>have to</em></strong> keep track of your depth in the recursion somewhere: either the runtime stack or your own stack.</p>  <p>But all you have to keep track of is where you are in each sequence at each level. You don't have to queue up all of the items at a given level. </p>  <p>Turns out the CLR has this obscure feature to handle this: <code>IEnumerator&lt;T&gt;</code>.</p>  <p>Yeah, not so obscure.</p>  <p>It's actually what the simple version of this code does. When you call down into the nested <code>SelectRecursiveSimle</code>, an <code>IEnumerator&lt;T&gt;</code> will be waiting patiently at the the current spot for the call to return.</p>  <h3>Getting Smart(er): SelectRecursive</h3>  <p>The code is more ugly, but it also does a better job of illuminating what is happening in the truly recursive, &quot;simple&quot; version.</p>  <div style="font-family: monospace"><span style="color: #0000ff">public</span>&#160;<span style="color: #0000ff">static</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; SelectRecursive&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span style="color: #0000ff">this</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span style="color: #2b91af">Func</span>&lt;TSource, <span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt;&gt; recursiveSelector)     <br />{     <br />&#160;&#160;&#160; <span style="color: #2b91af">Stack</span>&lt;<span style="color: #2b91af">IEnumerator</span>&lt;TSource&gt;&gt; stack = <span style="color: #0000ff">new</span>&#160;<span style="color: #2b91af">Stack</span>&lt;<span style="color: #2b91af">IEnumerator</span>&lt;TSource&gt;&gt;();     <br />&#160;&#160;&#160; stack.Push(source.GetEnumerator());     <br />    <br />&#160;&#160;&#160; <span style="color: #0000ff">while</span> (stack.Count &gt; 0)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">if</span> (stack.Peek().MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource current = stack.Peek().Current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> current;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Push(recursiveSelector(current).GetEnumerator());     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">else</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Pop();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}</div>  <p><strong><em><font color="#ff0000">2008-01-19: Turns out <a href="http://work.j832.com/2008/01/selectrecursive-if-3rd-times-charm-4th.html">this code is wrong</a>, too.</font></em></strong></p>  <p>The stack now holds on to what it should: the <code>IEnumerator&lt;T&gt;</code> at each level. The while loop runs through <code>IEnumerator&lt;T&gt;.MoveNext()</code>, going deeper with every <code>stack.Push()</code> until there are no more items and then &quot;returning&quot; with <code>stack.Pop()</code>.</p>  <h3>Popping the stack</h3>  <p>It's pretty easy to implement a recursive construct using Linq. The first &quot;simple&quot; implementation works great and it's really useful when partying over the file system or any other hierarchy.</p>  <p>I still claim that flattening recursive code is a good thing to do for reasons I mentioned on Tuesday.</p>  <p>Just make sure you do it correctly.</p>  <p>Put another way: pay attention to your <a href="http://work.j832.com/2007/12/when-you-code-do-you-know-your-masters.html">masters</a>.</p>  <p>If you can't be smart, be simple.</p>  <p>Don't <em><strong>ever</strong></em> be clever.</p>  <p>Clever will burn you.</p>  <p>&#160;</p>  <p>Happy hacking.</p>  <p>&#160;</p>  <p><a href="http://www.dotnetkicks.com/kick/?url=http%3a%2f%2fwork.j832.com%2f2008%2f01%2frecursion-linq-etc-3rd-times-charm.html"><img alt="kick it on DotNetKicks.com" src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http%3a%2f%2fwork.j832.com%2f2008%2f01%2frecursion-linq-etc-3rd-times-charm.html&amp;fgcolor=000000&amp;bgcolor=CCCCFF" border="0" /></a></p>  <p><em>PS: <a href="http://j832.com/PublicSoftware/">SVN</a> has been updated again with the latest code. Hopefully the last time I'll touch <code>RecursiveSelect</code> for a while.</em></p>  