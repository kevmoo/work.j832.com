---
layout: post
title: Improving NotifyWorker (and why blogging makes me smarter)
date: '2008-01-27T14:58:00.001-08:00'
author: Kevin Moore
tags:
- WPF
- ".NET"
- C#
- threading
modified_time: '2008-01-27T14:59:14.568-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-8294913857124617866
blogger_orig_url: http://work.j832.com/2008/01/improving-notifyworker-and-why-blogging.html
---

<p>My current day job consists of writing middleware and web-based LOB software for an <a href="http://actman.com/">actuarial services company</a>.</p>  <p><a href="http://dpotter.net/Technical/">David</a> is my primary collaborator and a fellow blogger. We get along amazingly well, but every once in a while, we disagree. The amazing thing, though, is how we handle disagreements.</p>  <p>I'm at a point where I look forward to disagreement! For a reason that I hope more people can come to realize.</p>  <p>If we disagree about how something should work, it's almost always an opportunity for improvement. Specifically, <em>at least</em> one of the following is likely to happen:</p>  <ul>   <li>I get smarter</li>    <li>He gets smarter</li>    <li>The code gets better</li> </ul>  <p>Quite often, it's all three. I know this sounds like motivational speaker talk or corporate training fodder, but it's true. The fact that we often discuss our disagreements with explicit reference to <a href="http://work.j832.com/2007/12/when-you-code-do-you-know-your-masters.html">masters</a> is also helpful.</p>  <p>I blog for similar reasons. I'm far from a CLR, C# or WPF expert, at least relative to the experts I've had the opportunity to work with.</p>  <p>I'm just a geek trying to figure things out and sharing as I go. Hopefully what I share is helpful. Often, though, blogging has self-serving benefits. Just taking the time to write down explanations for what I'm doing forces me to rationalize edge cases.</p>  <p>If I had never blogged the recursive flattening craziness, I would have never have seen all of the edge cases I had missed the first time out.</p>  <p>Anyway, to my point.</p>  <p>Simon was kind enough to point out a deadlock in my <a href="http://work.j832.com/2008/01/responsive-ui-with-unresponsive-data.html">NotifyWorker</a> code.</p>  <p><em>FYI: At this point, looking at <a href="http://j832.com/PublicSoftware/J832.Wpf.BagOTricksLibrary/NotifyWorker.cs">the code</a> will be quite helpful.</em></p>  <p>I was doing a Thread.Join() in the middle of a lock. Of course, if the thread in question is waiting on the lock which is held, the thread will never exit. The result: the Join() call will never return.</p>  <p>Deadlock, indeed.</p>  <p>Props to Simon for pointing out this problem.</p>  <p>I moved the Join() outside of the lock and thought I'd fixed the problem.</p>  <p>Maybe, but I also realized another problem.</p>  <ul>   <li>Dispose is likely called from the UI thread.</li>    <li>Dispose calls Join on my worker thread as discussed above.</li>    <li>The worker thread does Dispatcher.Invoke twice.</li> </ul>  <p>What happens if Dispose is called between my check for m_disposed and when the Invoke actually gets to the UI thread?</p>  <p>Dispose will be tying up the UI thread waiting for Join() to return. The worker thread will never terminate because it's waiting for Invoke to get to the UI thread.</p>  <p>Deadlock again.</p>  <p>Darn.</p>  <p>The solution: Move from Dispatcher.Invoke to Dispatcher.BeginInvoke.</p>  <p>BeginInvoke returns an instance of DispatcherOperation. This class has an Abort method which can be used to abort a pending BeginInvoke.</p>  <p>I now have an instance field containing the pending operation, if one exists, which can be aborted via Dispose before the call to Join. I also now enforce that Dispose must be called on the UI thread (by adding a call to VerifyAccess). This ensures that Abort is not called while the worker is synchronized to the UI thread.</p>  <p>After some careful uses of DisaptcherOperation.Wait and some paranoid null checks, I think I'm okay.&#160; </p>  <p>As an aside, I also noticed that Dispose() will throw in the case where NotifyNewWork() has never been called. I fixed that, too.</p>  <p>*Sigh*</p>  <p>Threading code is tough. I had to stand up and pace around a few times as I mentally worked through possible edge cases.</p>  <p>As I've said before, I think this implementation is better, but it would be a stretch for me to claim it's correct. Hopefully, it's more correct.</p>  <p>Please keep the questions, comments, and feedback coming (after you take a look at <a href="http://work.j832.com/2008/01/oleg-what-your-email-contacting-me-via.html">the post</a> about contacting me).</p>  <p>The code will get better and we'll all get smarter.</p>  <p>&#160;</p>  <p>Happy hacking.</p>  