---
layout: post
title: 'Responsive UI with Unresponsive Data: NotifyWorker'
date: '2008-01-22T14:47:00.001-08:00'
author: Kevin Moore
tags:
- WPF
- Programming
- ".NET"
- C#
- threading
modified_time: '2008-01-24T00:44:06.503-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-8386454723537919110
blogger_orig_url: http://work.j832.com/2008/01/responsive-ui-with-unresponsive-data.html
---

<p></p>  <p><em>Yes, I finally got <a href="http://work.j832.com/2008/01/flattening-recursive-algorithms-is-like.html">off</a> <a href="http://work.j832.com/2008/01/flattening-recursive-algorithms-with.html">my</a> <a href="http://work.j832.com/2008/01/recursion-linq-etc-3rd-times-charm.html">SelectRecursive</a> <a href="http://work.j832.com/2008/01/selectrecursive-if-3rd-times-charm-4th.html">kick</a>. This is penance.</em></p>  <h3>The 3-box Visio Diagram</h3>  <p>How many user interfaces do you design that follow this pattern?</p>  <p><img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="84" alt="image" src="http://j832.com/workBlogFiles/_images/ResponsiveUIwithUnresponsiveDataLayers_CFF3/image.png" width="366" border="0" /> </p>  <p>Okay, almost all of them.</p>  <p>A frequent refrain from users (well, at least me):</p>  <blockquote>   <p>Regardless of what you're doing behind-the-scenes, the interface should <em><strong>never</strong></em> hang, stutter, or lag. <strong><em>Ever</em></strong>.</p> </blockquote>  <p>Easily said, right?</p>  <p>Well, while hacking on one of my side projects, I ran into this problem.</p>  <p>I put on my &quot;framework guy&quot; hat and asked, &quot;Can I formalize this into a pattern?&quot;</p>  <p>My answer: NotifyWorker.</p>  <p>Now before I get into NotifyWorker, I should mention <a href="http://msdn2.microsoft.com/en-us/library/8xs8549b.aspx">BackgroundWorker</a>: a frequently used and well thought-out component supplied by our friends in the Baseclass Library (BCL) for this kind of thing.</p>  <p>The trick performed by BackgroundWorker is simple, but important: allow start/stop/cancel of a task on another thread. It also keeps developers sane who have to deal with strict rules about what can only be done on the UI thread.</p>  <p>The type of tasks for which NotifyWorker was designed fit into a special niche that I think BackgroundWorkre misses:</p>  <ul>   <li>Tasks that are long enough to lag the interface (0.1+ seconds) but are too short to require tracking of percent complete (so shorter than, say, 5 seconds). </li>    <li>Tasks that are repeated constantly as the UI updates. Think of recalculating a math/physics model or checking a server-hosted word list for a type-a-head find control. </li>    <li>Tasks where the work to be done is--in relative terms--longer than the work to update the user interface. If the task takes 0.1 seconds, but updating the 1,000 controls in your window takes 2 seconds, you should start by tweaking your architecture before using NotifyWorker. </li> </ul>  <h3>How does it work?</h3>  <p><em>(Reflector is how I learn all of my new APIs.)</em></p>  <p><img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="292" alt="image" src="http://j832.com/workBlogFiles/_images/ResponsiveUIwithUnresponsiveDataLayers_CFF3/image_3.png" width="426" border="0" /> </p>  <p>The constructor takes three parameters that outline the diagram above and the workings of NotifyWorker:</p>  <ul>   <li><strong>Func&lt;bool&gt; prework</strong>: this is a delegate that is called on the Dispatcher (UI) thread in a WPF application. Delegate passing is a trick I use a lot, and you should, too. The method does the work to take interesting parameters from the UI (control values, etc.) and puts them in a spot where NotifyWorker can safely play on a non-UI thread. If you decide there is nothing interesting to do, you can return false, telling NotifyWorker &quot;never mind&quot;.</li>    <li><strong>Action work</strong>: this is where the magic happens. This function is called on a background thread which will leave your UI nice and responsive. Be super careful that 'work' only touches state (fields, etc) that you've safely set aside during prework.</li>    <li><strong>Action postWork</strong>: the last box in our diagram. It takes the work done in 'work' and updates the UI accordingly. This method, as well as 'preWork', synchronizes the UI and background threads, so you don't have to worry about locking.</li> </ul>  <p>How do you kick things off? Call NotifyNewWork. This method can be called often, if you want. Put it in the 'Changed' handler of your favorite Slider or TextBox. If NotifyWorker is idle, it will wake up and immediately call preWork. If NotifyWorker is busy, it'll loop right around to get new input values as soon as postWork is done.</p>  <h3>A demo</h3>  <p><img style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="223" alt="image" src="http://j832.com/workBlogFiles/_images/ResponsiveUIwithUnresponsiveDataLayers_CFF3/image_4.png" width="459" border="0" /> </p>  <p>Sexy, huh?</p>  <p>The scenario is simplistic and contrived, like so many good demos.</p>  <p>Both sets of UI do the same thing: take the values from two sliders and sum them. Not too complicated.</p>  <p>For some strange reason, the sum 'routine' takes 0.25 seconds to return a result.</p>  <p>Maybe it's that new math...</p>  <p>Eh, it's probably the Thread.Sleep(250) I put in the method.</p>  <p>Anyway, use your imagination. You'll notice that the 'slow' UI is, well, slower. It lags a bunch as you drag the sliders since it's calling the expensive sum method on the UI thread.</p>  <p>The NotifyWorker controls do much better because the expensive call is hidden off-thread.</p>  <p>Simple, but useful.</p>  <h3>Odds and ends</h3>  <p>You'll notice a LastClientExceptionEventArgs property and a ClientException event. These are designed to make it a bit easier to handle non-critical exceptions during 'work'. The demo code actually shows this off pretty well.</p>  <p>You'll also notice that NotifyWorker implements IDisposable. Dispose will make sure to end any background work when you're done with NotifyWorker.</p>  <p>Under the covers, NotifyWorker uses <a href="http://work.j832.com/2007/11/going-beyond-monitorenterexit-c-lock.html">LockHelper</a> and some of the <a href="http://work.j832.com/2007/10/threading-fun-monitorwait-monitorpulse.html">pulse/monitor tricks I wrote about</a> a few months ago.</p>  <h3>That's about it.</h3>  <p>Since NotifyWorker is hard-wired to the notion the Dispatcher, it lives in J832.Wpf.BackOTricksLib. The demo is in the Bag-o-Tricks app under NotifyWorker.</p>  <p>I'm <strong><em>not</em></strong> going to do an official release (zip with binaries/source) of the bag for this sample. It's cool, but not cool enough to warrant a whole new drop.</p>  <p>It also gives you an excuse to <a href="http://work.j832.com/2007/12/tortoisesvn-rocks.html">play with SVN</a>, if you haven't already. You can always just manually download the code from my <a href="http://j832.com/PublicSoftware/">SVN share</a> using your browser, too.</p>  <p>Let me know if this works well for you.</p>  <p>&#160;</p>  <p>Happy multi-threaded hacking!</p>  <p>&#160;</p>  <p><em>Note: I've had some funky auth issues with Firefox on the SVN server lately. Let me know if you have any trouble.</em></p>  