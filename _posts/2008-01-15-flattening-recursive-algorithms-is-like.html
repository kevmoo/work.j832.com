---
layout: post
title: Flattening recursive algorithms is like taking the stairs...
date: '2008-01-15T20:05:00.001-08:00'
author: Kevin Moore
tags:
- Programming
- ".NET"
- C#
- interesting
modified_time: '2008-01-19T18:55:55.341-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-6128588860528889593
blogger_orig_url: http://work.j832.com/2008/01/flattening-recursive-algorithms-is-like.html
---

<p>...it's rarely necessary, but you'll be better for it.</p>  <p>Okay, a forced analogy.</p>  <p><strong><em><font color="#ff0000">2008-01-19: I've learned a lot since Tuesday. </font><font color="#ff0000"><a href="http://work.j832.com/2008/01/selectrecursive-if-3rd-times-charm-4th.html">Please read!</a></font></em></strong></p>  <p>I'm sure many remember their first algorithms class and their first introduction to recursion: the infamous <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">Tower of Hanoi</a> problem. I'd been coding for a while when I was presented with this puzzle and wondered (probably out loud), &quot;Why don't we use a more concrete example, like the file system?&quot;</p>  <p>I guess I've always been more of a software engineer than a computer scientist.</p>  <p>While the idea of recursion is useful in many situations, the costs are rarely discussed. As our friends at Wikipedia <a href="http://en.wikipedia.org/wiki/Recursion_%28computer_science%29">mention</a>:</p>  <blockquote>   <p>...in today's programming languages, the stack space available to a thread is often much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms.</p> </blockquote>  <p>Well said.</p>  <p>I was hacking on some work stuff that required recursion-- specifically flattening a hierarchy. I realized I'd done this before, in the <a href="http://j832.com/bagotricks/">bag-o-tricks</a>. I also realized how expensive it was.</p>  <p><a href="http://j832.com/workBlogFiles/_images/Flatteningrecursivealgorithmsisliketaki_11A6D/image.png"><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="306" alt="Call stack for recursive function call" src="http://j832.com/workBlogFiles/_images/Flatteningrecursivealgorithmsisliketaki_11A6D/image_thumb.png" width="404" border="0" /></a> </p>  <p>Not only was I paying in call stack space for every nested call, but I was also allocating a lot of enumerators. </p>  <p><em>Code for the SelectedDirectories getter.</em></p>  <div style="font-family: monospace"><span style="color: #0000ff">if</span> (m_directories != <span style="color: #0000ff">null</span>)     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000ff">foreach</span> (<span style="color: #2b91af">SelectableDirectory</span> sd <span style="color: #0000ff">in</span> m_directories)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">if</span> (sd.IsSelected)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> sd;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">foreach</span> (<span style="color: #2b91af">SelectableDirectory</span> sd2 <span style="color: #0000ff">in</span> sd.SelectedDirectories)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> sd2;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}     <br /></div>  <p>So how does one improve this? Replace the call stack with your own stack.</p>  <div style="font-family: monospace"><span style="color: #2b91af">Stack</span>&lt;<span style="color: #2b91af">SelectableDirectory</span>&gt; directoryStack = <span style="color: #0000ff">new</span>&#160;<span style="color: #2b91af">Stack</span>&lt;<span style="color: #2b91af">SelectableDirectory</span>&gt;();    <br />directoryStack.Push(<span style="color: #0000ff">this</span>);    <br /><span style="color: #0000ff">while</span> (directoryStack.Count &gt; 0)    <br />{    <br />&#160;&#160;&#160; <span style="color: #2b91af">SelectableDirectory</span> currentDir = directoryStack.Pop();    <br />&#160;&#160;&#160; <span style="color: #0000ff">if</span> (currentDir.m_directories != <span style="color: #0000ff">null</span>)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">for</span> (<span style="color: #0000ff">int</span> i = (currentDir.m_directories.Count - 1); i &gt;= 0; i--)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; directoryStack.Push(currentDir.m_directories[i]);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; <span style="color: #0000ff">if</span> (currentDir.IsSelected)    <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> currentDir;    <br />&#160;&#160;&#160; }    <br />}</div>  <p><em>The savvy reader will notice that the second implementation is slightly different: the target node is included if it is selected. Just a detail.</em></p>  <p>So, what has improved? Only one enumerator is created. The call stack space for the recursion is also eliminated. The cost is the creation of the local Stack&lt;&gt; to keep track of the location in the hierarchy, which is likely much smaller than the space required for a call stack frame.</p>  <p>Since we want to keep the original order of items returned, we also have to Push each level of directories into the Stack in reverse order, so that the Stack returns them in the original order.</p>  <p>Now how does this match up with <a href="http://work.j832.com/2007/12/when-you-code-do-you-know-your-masters.html">our masters</a>?</p>  <p>It's certainly less readable. Since the code's not documented, it would probably take longer for even a savvy dev to figure out what's going on. This means it's less maintainable--certainly a negative.</p>  <p>On the plus size, the scalability of this algorithm is now limited by the size of the heap, which is much larger than the call stack. This only matters if one plans to parse very deep directory structures, though.</p>  <p>Another plus is likely performance, since fewer objects are instantiated and the cost of manipulating a local Stack&lt;&gt; is likely much cheaper than churning the call stack. I say 'likely' because I'm not really sure. I should absolutely measure the performance to be certain. Even then, the perf gain is likely trivial unless this code is called a lot. In that case, it might make sense to cache the result of the method.</p>  <p>In the end (and as always), context really matters. I think this is a good exercise to understand the costs and to challenge one's understanding of recursion. If you can flatten a recursive implementation, you will have a better understanding of what's really going on under the covers--something that is always useful.</p>  <p>Happy hacking!</p>  <p><em>Note: the updated code for Folder Picker has been committed to the bag-o-tricks directory in <a href="http://j832.com/PublicSoftware/">my SVN repository</a>. You can take a look at the old implementation using <a href="http://tortoisesvn.tigris.org/">Tortoise</a>. Right-click on Data.cs in the shell. Pick 'Show log' out of the Tortoise menu. Then right-click on revision 58 and pick 'Update item to revision'.</em></p>  <p><a href="http://j832.com/workBlogFiles/_images/Flatteningrecursivealgorithmsisliketaki_11A6D/image_3.png"><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="342" alt="Update to revision" src="http://j832.com/workBlogFiles/_images/Flatteningrecursivealgorithmsisliketaki_11A6D/image_thumb_3.png" width="404" border="0" /></a></p>  