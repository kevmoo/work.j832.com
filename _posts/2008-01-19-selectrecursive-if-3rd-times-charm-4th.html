---
layout: post
title: 'SelectRecursive: If 3rd times the charm, 4th times a warning'
date: '2008-01-19T18:49:00.001-08:00'
author: Kevin Moore
tags: 
modified_time: '2008-01-20T09:12:11.053-08:00'
blogger_id: tag:blogger.com,1999:blog-2115056243892631308.post-1080842744418743612
blogger_orig_url: http://work.j832.com/2008/01/selectrecursive-if-3rd-times-charm-4th.html
---

<p>I thought I finally nailed <code>SelectRecursive</code>--my Linq-friendly extension method for navigating homogenous hierarchies. In my infinite cleverness, I figured I could avoid paying the common call stack cost of recursive algorithms by creating my own stack.</p>  <p>The solution I <a href="http://work.j832.com/2008/01/flattening-recursive-algorithms-with.html">posted Wednesday</a> was an okay start of the philosophy, but I really messed up the implementation.</p>  <p>I thought I got it right <a href="http://work.j832.com/2008/01/recursion-linq-etc-3rd-times-charm.html">yesterday</a>, but after being bitten once, I was cautious--notice I said &quot;Smart(er)&quot;.</p>  <p>Well, the implementation yesterday was certainly better, but it was missing a critical component: correct clean-up.</p>  <p><code>IEnumerator&lt;T&gt;</code> implements <code>IDisposable</code>.</p>  <p>Why? Well, suppose you're enumerating over a database table. When one is done walking through the items, you might want to close your connection.</p>  <p>We rarely see the use of <code>IDisposable</code> in this context, because it's hidden behind the 99.999% use of <code>IEnumerable&lt;T&gt;</code>--<code>foreach</code>.</p>  <p>Don't forget that this:</p>  <div style="font-family: monospace"><span style="color: #0000ff">foreach</span> (<span style="color: #0000ff">object</span> item <span style="color: #0000ff">in</span> sourceEnum)     <br />{     <br />&#160;&#160;&#160; <span style="color: #008000">// do something</span>     <br />}</div>  <p>Looks like this to the runtime:</p>  <div style="font-family: monospace"><span style="color: #0000ff">using</span> (<span style="color: #2b91af">IEnumerator</span>&lt;<span style="color: #0000ff">object</span>&gt; source = sourceEnum.GetEnumerator())     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000ff">while</span> (source.MoveNext())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000">// do something</span>     <br />&#160;&#160;&#160; }     <br />}     <br /></div>  <p>Well, actually it looks like this:</p>  <div style="font-family: monospace"><span style="color: #2b91af">IEnumerator</span>&lt;<span style="color: #0000ff">object</span>&gt; source = sourceEnum.GetEnumerator();     <br /><span style="color: #0000ff">try</span>     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000ff">while</span> (source.MoveNext())     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #008000">// do something</span>     <br />&#160;&#160;&#160; }     <br />}     <br /><span style="color: #0000ff">finally</span>     <br />{     <br />&#160;&#160;&#160; source.Dispose();     <br />}     <br /></div>  <p><code>foreach</code> does the work of calling <code>Dispose()</code> on the enumerator--both when things go well and if there is an exception thrown in the while loop.</p>  <p>Since the &quot;simple&quot; version of <code>SelectEnumerator</code> I posted yesterday uses <code>foreach</code>, everything works great. Even if an exception is thrown deep in the recursion, the unrolling of the stack will go through all of the nested finally blocks.</p>  <p>The &quot;smart(er)&quot; version of <code>SelectEnumerator</code> will have to be smart to handle disposing every enumerator it creates--both when the stack is popped normally and in the case of an exception.</p>  <div style="font-family: monospace"><span style="color: #0000ff">public</span>&#160;<span style="color: #0000ff">static</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; SelectRecursive&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span style="color: #0000ff">this</span>&#160;<span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt; source,     <br />&#160;&#160;&#160; <span style="color: #2b91af">Func</span>&lt;TSource, <span style="color: #2b91af">IEnumerable</span>&lt;TSource&gt;&gt; recursiveSelector)     <br />{     <br />&#160;&#160;&#160; <span style="color: #2b91af">Stack</span>&lt;<span style="color: #2b91af">IEnumerator</span>&lt;TSource&gt;&gt; stack = <span style="color: #0000ff">new</span>&#160;<span style="color: #2b91af">Stack</span>&lt;<span style="color: #2b91af">IEnumerator</span>&lt;TSource&gt;&gt;();     <br />&#160;&#160;&#160; stack.Push(source.GetEnumerator());     <br />    <br />&#160;&#160;&#160; <span style="color: #0000ff">try</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">while</span> (stack.Count &gt; 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">if</span> (stack.Peek().MoveNext())     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TSource current = stack.Peek().Current;     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">yield</span>&#160;<span style="color: #0000ff">return</span> current;     <br />    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Push(recursiveSelector(current).GetEnumerator());     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">else</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Pop().Dispose();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span style="color: #0000ff">finally</span>     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000ff">while</span> (stack.Count &gt; 0)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stack.Pop().Dispose();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>  <p>Take a look at the <a href="http://work.j832.com/2008/01/recursion-linq-etc-3rd-times-charm.html">code from yesterday</a> to see the diff. </p>  <p>At this point, I'm pretty nervous about saying I've gotten this &quot;right&quot;. In all honesty, I did the stack flattening to see if I could do it and do it well.</p>  <p>As I've mentioned before, this pattern is only useful if you plan on having prohibitively deep hierarchies where the cost of the churning the runtime stack or the chance of stack overflow is high.</p>  <p>If neither is the case, keep things simple.</p>  <p>Remember what I said about clever.</p>  <p>&#160;</p>  <p>Happy hacking.</p>  